<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Promise</title>
</head>
<body>

    <div onClick = {promiseClick}>开始异步请求</div>

    <script>
        /**
        * 1.什么是Promise
        * Promise 是异步编程的一种解决办法，其实是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。
        * 
        * Promise对象有以下两个特点：
        * 1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending(进行中)、fulfilled(已成功)和rejected(已失败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
        * 2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会在变了，会一直保持这个结果，这时就称为resolved(已定型)。如果改变已经发生了，你在对Promise对象添加回调函数，也会立即得到这个结果。这与事件(Event)完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
        */

        // 下面先 new 一个 Promise

        // let p =new Promise(function(resolve,reject){
        //     // 做一些异步操作
        //     setTimeout(function(){
        //         console.log('执行完成Promise');
        //         resolve('要返回的数据可以任何数据例如接口返回数据');
        //     },2000)
        // })

        // 刷新页面控制台会打印出------执行完成Promise

        // 执行过程是：执行了一个异步操作，也就是setTimeout,两秒后，输出“执行完成Promise”，并且调用resolve方法。
        // 注意！我们只是 new 了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包含在一个函数中，在需要的时候去运行这个函数。
        
        
        // <div onClick = {promiseClick}>开始异步请求</div>
        const promiseClick=()=>{
            console.log('点击方法被调用')
            let p = new Promise(function(resolve, reject){
                //做一些异步操作
                setTimeout(function(){
                    console.log('执行完成Promise');
                    resolve('要返回的数据可以任何数据例如接口返回数据');
                },2000);
            })
            return p
        }
        
        // 刷新页面的时候没有任何反应，但是点击后控制台会打印出------点击方法被调用   执行完成Promise

        /**
        * 当放在函数里面的时候只有调用的时候才会被执行
        * 接下来解决两个问题：
        * 1.为什么要放在函数里面
        * 2.resolve是什么
        * 我们包装好的函数最后，会 return 出 Promise 对象，也就是说，执行这个函数我们得到了一个Promise对象。接下来就可以用 Promise 对象上有 then、catch方法了，这是就是Promise的强大之处
        */

        promiseClick().then(function(data){
            console.log(data)
            // 后面可以用传过来的数据做些其他操作
            // ......
        })

        // 控制台输出------点击方法被调用   执行完成Promise   要返回的数据可以任何数据例如接口返回数据

        /**
        * 先是方法被调用执行了Promise，最后执行了Promise的then方法，then方法是一个函数接收一个参数是接收resolve返回的数据这时就输出了‘要返回的数据可以任何数据例如接口返回数据’
        * then里面的函数跟我们平时的回调函数是一个意思，能够在promiseClick这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。
        * 虽然这个和写一个回调函数没有什么区别，但是如果是多层回调呢？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后该callback传进去。而Promise的优势在于，可以再then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。
        * 所以：精髓在于：Promise只是能够简化层层回调的写法，而实际上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。
        */

        promiseClick().then(function(data){
            console.log(data);
            return runAsync2();
        }).then(function(data){
            console.log(data);
            return runAsync3();
        }).then(function(data){
            console.log(data);
        })

        // 这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。
    </script>
</body>
</html>